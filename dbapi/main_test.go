package dbapi

import (
	"net/http"
	"net/url"
	"testing"

	"github.com/ohthehugemanatee/db-to-ynab-golang/tools"
	"golang.org/x/oauth2"
	"gopkg.in/h2non/gock.v1"
)

const (
	dummyClientID string = "aa4e5eae-ee59-4d54-ee5f-ce65d02f4ed6"
)

func TestAuthorize(t *testing.T) {
	t.Run("Authorize returns a url if there's no refresh token.", func(t *testing.T) {
		expect := "https://example.com/authorize/me"
		currentToken.RefreshToken = ""
		oauth2Conf.Endpoint.AuthURL = expect
		oauth2Conf.ClientID = dummyClientID
		got := Authorize()
		if got == "" {
			t.Error("Did not return a refresh token URL.")
		}
		gotURL, _ := url.Parse(got)
		URIWithoutQuery := gotURL.Scheme + "://" + gotURL.Host + gotURL.Path
		if URIWithoutQuery != expect {
			t.Errorf("Returned an incorrect refresh token URL. Got %s, expected %s", URIWithoutQuery, expect)
		}
		// Validate that the URL was generated by oauth2.
		expectedParams := map[string]string{
			"access_type":   "offline",
			"client_id":     dummyClientID,
			"response_type": "code",
			"scope":         "read_transactions read_accounts read_credit_cards_list_with_details read_credit_card_transactions offline_access",
			"state":         "state",
		}
		for key, value := range expectedParams {
			result := gotURL.Query().Get(key)
			if result != value {
				t.Errorf("Authorize URL had wrong/missing parameter %s. Got %s expected %s", key, result, value)
			}
		}
	})
}

func TestAuthorizedHandler(t *testing.T) {
	setTestOauth2Config()
	t.Run("Failure with an empty \"code\" parameter", func(t *testing.T) {
		t.Parallel()
		responseRecorder := runDummyRequest(t, "GET", "/authorized", AuthorizedHandler)
		tools.AssertStatus(t, http.StatusInternalServerError, responseRecorder.Code)
	})
	t.Run("Pass with a valid code parameter", func(t *testing.T) {
		defer gock.Off()
		gock.New(dbAPIBaseURL).
			Post("/gw/oidc/token").
			Reply(200).
			JSON(map[string]string{"access_token": "ACCESS_TOKEN", "token_type": "bearer"})

		gock.New(dbAPIBaseURL).
			Post("/gw/oidc/token").
			Reply(200).
			JSON(map[string]string{"access_token": "ACCESS_TOKEN", "token_type": "bearer"})

		responseRecorder := runDummyRequest(t, "GET", "/authorized?code=abcdef", AuthorizedHandler)
		tools.AssertStatus(t, http.StatusFound, responseRecorder.Code)
	})
}

func TestCheckParams(t *testing.T) {
	t.Run("Panic when missing a parameter", func(t *testing.T) {
		var values [5]string
		// Try checking params with each possible param empty.
		for i := range values {
			values[i] = "dummy_value"
		}
		for i := range values {
			valuesWithOneEmpty := values
			valuesWithOneEmpty[i] = ""
			setParams(valuesWithOneEmpty)
			err := CheckParams()
			if err == nil {
				t.Errorf("Missing parameter did not return an error")
			}
		}

	})
}

func TestSetCurrentToken(t *testing.T) {
	t.Run("Set a token and retrieve it later", func(t *testing.T) {
		tokenValue := "testing-current-token"
		SetCurrentToken(&oauth2.Token{AccessToken: tokenValue})
		if currentToken.AccessToken != tokenValue {
			t.Errorf("Failed retrieving set token. Got %s expected %s", currentToken.AccessToken, tokenValue)
		}
	})
}

func setParams(values [5]string) {
	accountNumber = values[0]
	dbClientID = values[1]
	dbClientSecret = values[2]
	dbAPIBaseURL = values[3]
	redirectURL = values[4]
}

func setTestOauth2Config() {
	dbAPIBaseURL = "https://example.com/"
	oauth2Conf = &oauth2.Config{
		ClientID:     dbClientID,
		ClientSecret: dbClientSecret,
		Scopes:       []string{"read_transactions", "read_accounts", "read_credit_cards_list_with_details", "read_credit_card_transactions", "offline_access"},
		Endpoint: oauth2.Endpoint{
			AuthURL:  dbAPIBaseURL + "gw/oidc/authorize",
			TokenURL: dbAPIBaseURL + "gw/oidc/token",
		},
	}
}
